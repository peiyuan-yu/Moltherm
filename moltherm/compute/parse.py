# coding: utf-8

import os
import re
from bs4 import BeautifulSoup

from pymongo.errors import DuplicateKeyError, ConnectionFailure

from pymatgen.io.babel import BabelMolAdaptor
from atomate.qchem.database import QChemCalcDb

__author__ = "Evan Spotte-Smith"
__version__ = "0.2"
__maintainer__ = "Evan Spotte-Smith"
__email__ = "espottesmith@gmail.com"
__status__ = "Beta"
__date__ = "June 2018"


class ReaxysParser:
    """
    Parser for reaction data from the Reaxys reaction database. This class can
    extract important reaction metadata from an exported XML file, restore that
    pertinent information, including molecule structure files (*.mol), and
    interact with a database for additional storage.
    """

    def __init__(self, base_dir):
        """
        ReaxysScraper

        :param base_dir: Base directory for parsing and generating data.
        """

        self.base_dir = base_dir

    def parse_reaxys_xml(self, filename):
        """
        Parses an XML file generated by the Reaxys API.

        :param filename: str referring to XML file from Reaxys.
        :return: List of dicts including reactant CTAB, product CTAB, and
        metadata.
        """

        results = []

        filepath = os.path.join(self.base_dir, filename)

        with open(filepath, 'r') as fileobj:
            xml = fileobj.read()
            parsed = BeautifulSoup(xml, "lxml-xml")

            reactions = parsed.find_all("reaction")

            for reaction in reactions:
                # Screen for reactions with more than two reactants
                # or more than one product
                pros = reaction.find_all("RY.PRO")
                rcts = reaction.find_all("RY.RCT")
                if not ((len(pros) == 1 and len(rcts) == 2) or (len(pros) == 2 and len(rcts) == 1)):
                    continue

                # Generate metadata from reaction header information
                # Will be passed along with CTAB information
                index = int(reaction["index"])
                rxn_id = int(reaction.find("RX.ID").text)
                solvents = set([sol.text for sol
                                in reaction.find_all("RXD.SOL")])

                rct_ids = reaction.find_all("RX.RXRN")
                rct_names = reaction.find_all("RX.RCT")
                rct_meta = [(int(e.text), rct_names[i].text) for i, e
                            in enumerate(rct_ids)]

                pro_ids = reaction.find_all("RX.PXRN")
                pro_names = reaction.find_all("RX.PRO")
                pro_meta = [(int(e.text), pro_names[i].text) for i, e
                            in enumerate(pro_ids)]

                meta = {"index": index,
                        "rxn_id": rxn_id,
                        "solvents": solvents,
                        "rct_meta": sorted(rct_meta, key=lambda x: x[0]),
                        "pro_meta": sorted(pro_meta, key=lambda x: x[0])}

                # Capture reactant CTAB information
                # Make sure that ordering is the same for metadata and CTAB
                rcts = sorted(reaction.find_all("RY.RCT"),
                              key=lambda x: int(x["rn"]))
                rcts = [rct.text for rct in rcts]

                pros = sorted(reaction.find_all("RY.PRO"),
                              key=lambda x: int(x["rn"]))

                pros = [pro.text for pro in pros]

                rxn = {"rcts": rcts, "pros": pros, "meta": meta}

                try:
                    pro_atoms = []
                    for pro in rxn["pros"]:
                        ad = BabelMolAdaptor.from_string(pro, file_format="mol")
                        ad.add_hydrogen()
                        for site in ad.pymatgen_mol:
                            pro_atoms.append(str(site.specie))

                    rct_atoms = []
                    for rct in rxn["rcts"]:
                        ad = BabelMolAdaptor.from_string(rct, file_format="mol")
                        ad.add_hydrogen()
                        for site in ad.pymatgen_mol:
                            rct_atoms.append(str(site.specie))

                    if sorted(pro_atoms) == sorted(rct_atoms):
                        results.append(rxn)
                except:
                    continue

        return results

    def get_unique_reactions(self, files):
        """
        Parses a set of Reaxys XML files and filter out duplicates.

        :param files: List of strings representing Reaxys XML files to be processed.
        :return: unique_ids (list of strings representing Reaxys ids) and unique
            (list of dicts representing unique reactions)
        """

        overall = []

        for file in files:
            res = self.parse_reaxys_xml(file)
            overall += res

        unique_ids = []
        unique = []
        for rxn in overall:
            if rxn["meta"]["rxn_id"] not in unique_ids:
                unique_ids.append(rxn["meta"]["rxn_id"])
                unique.append(rxn)

        return unique_ids, unique

    def store_reaxys_reactions_files(self, reactions, base_path=None):
        """
        Create CTAB (.mol) files and metadata XML files from parsed XML data.

        :param reactions: List of reactions, defined as above.
        :param base_path: If not None (default), the base directory in which to
            store reaction and molecule data
        :return:
        """

        for reaction in reactions:
            rxn_id = reaction["meta"]["rxn_id"]
            index = reaction["meta"]["index"]

            if base_path is None:
                path = os.path.join(self.base_dir, "reactions")
            else:
                path = os.path.join(base_path, "reactions")

            if not os.path.exists(path):
                os.makedirs(path)

            # Create metadata file
            with open(os.path.join(path, "{}.xml".format(rxn_id)), 'w') as file:
                file.write("<metadata>")
                file.write("<index>%(index)s</index>\n" % {"index": str(index)})
                file.write("<reaxysid>%(id)s</reaxysid>\n" % {"id": str(rxn_id)})

                file.write("<solvents>%(solvents)s</solvents>\n" % {"solvents": " || ".join(reaction["meta"]["solvents"])})

                for i, rct in enumerate(reaction["meta"]["rct_meta"]):
                    rct_info = {"num": str(i),
                                "name": rct[1],
                                "id": str(rct[0])
                                }
                    file.write("""<rct num=%(num)s>
<rctname>%(name)s</rctname>
<rctid>%(id)s</rctid>
</rct>\n""" % rct_info)

                for i, pro in enumerate(reaction["meta"]["pro_meta"]):
                    pro_info = {"num": str(i),
                                "name": pro[1],
                                "id": str(pro[0])}
                    file.write("""<pro num=%(num)s>
<proname>%(name)s</proname>
<proid>%(id)s</proid>
</pro>\n""" % pro_info)

                file.write("</metadata>")

            if base_path is None:
                path = os.path.join(self.base_dir, "molecules")
            else:
                path = os.path.join(base_path, "molecules")

            if not os.path.exists(path):
                os.makedirs(path)

            # Create reactant files, named with their Reaxys IDs
            reactants = reaction["meta"]["rct_meta"]
            for i, e in enumerate(reactants):
                rct_path = os.path.join(path, str(e[0]))
                if not os.path.exists(rct_path):
                    os.makedirs(rct_path)
                filename = str(e[0]) + ".mol"
                with open(os.path.join(rct_path, filename), 'w') as file:
                    file.write(reaction["rcts"][i])

            # Create product file, named with its Reaxys ID
            products = reaction["meta"]["pro_meta"]
            for i, e in enumerate(products):
                pro_path = os.path.join(path, str(e[0]))
                if not os.path.exists(pro_path):
                    os.makedirs(pro_path)
                filename = str(e[0]) + ".mol"
                with open(os.path.join(pro_path, filename), 'w') as file:
                    file.write(reaction["pros"][i])

    @staticmethod
    def store_reaxys_reactions_db(reactions, db_file="db.json",
                                  collection_name="reaxys"):
        """
        Insert reaction information into a MongoDB database.

        :param reactions: List of reactions, defined as above.
        :param db_file: A config file indicating the database into which the
        reactions will be inserted.
        :param collection_name: Collection within the database in which to store
        the reactions.
        :return: List of rxn_ids that were added to collection collection_name
        as a result of this method call
        """

        # Set up MongoDB database with pymatgen-db and pymongo
        try:
            db = QChemCalcDb.from_db_file(db_file)
        except:
            raise RuntimeError("Cannot connect to database. Please check your"
                               " configuration and try again.")

        collection = db.db[collection_name]

        just_added = []

        collection.create_index("rxn_id", unique=True)

        for reaction in reactions:
            # Reorganize for database insertion
            rxn = {}
            rxn["rxn_id"] = str(reaction["meta"]["rxn_id"])
            rxn["pro_ids"] = [str(p[0]) for p in reaction["meta"]["pro_meta"]]
            rxn["pro_names"] = [p[1] for p in reaction["meta"]["pro_meta"]]
            rxn["rct_ids"] = [str(r[0]) for r in reaction["meta"]["rct_meta"]]
            rxn["rct_names"] = [r[1] for r in reaction["meta"]["rct_meta"]]
            rxn["solvents"] = list(reaction["meta"]["solvents"])

            try:
                collection.insert_one(rxn)
                just_added.append(rxn["rxn_id"])
            except DuplicateKeyError:
                continue

        return just_added


class EPISuiteParser:
    """
    This class processes outputs from the Environmental Protection Agency's
    EPI Suite. It can also interface with a MongoDB database in order to store
    this data.

    """

    @staticmethod
    def parse_epi_suite_summary(file):
        """
        Parse predicted data from the US EPA's EPI Suite batch mode.

        Currently, this function only extracts the predicted boiling point,
        melting point, and solubility.

        :param file: Path to EPI Suite output file.
        :return: list of dicts with predicted molecular data
        """

        parsed_results = []

        with open(file, 'r', encoding="ISO-8859-1") as file:
            entries = file.read().split("\n\n========================\n\n")[0:-1]

            for entry in entries:
                smiles = re.search(r"SMILES\s+:\s+([A-Za-z0-9=\(\)#\[\]\+\-@]+\n?\s*[A-Za-z0-9=\(\)#\[\]\+\-@]*)",
                                   entry)
                if smiles:
                    smiles = smiles.group(1).replace("\n", "").replace(" ", "").replace("CHEM", "")
                else:
                    smiles = None

                name = re.search(r"CHEM\s+:\s+([A-Z/_a-z0-9]+)\s*", entry)
                if name:
                    mol_id = name.group(1)
                else:
                    mol_id = None

                bp = re.search(r"\s+Boiling Pt \(deg C\):\s+(\-?[0-9]+\.[0-9]+)\s+\(Adapted Stein & Brown method\)", entry)
                if bp:
                    bp = float(bp.group(1))
                else:
                    bp = None

                mp = re.search(r"\s+Melting Pt \(deg C\):\s+(\-?[0-9]+\.[0-9]+)\s+\(Mean or Weighted MP\)", entry)
                if mp:
                    mp = float(mp.group(1))
                else:
                    mp = None

                vp = re.search(r"\s+VP \(Pa, 25 deg C\)\s+:\s+([0-9]+\.?[0-9]*[Ee]?[0-9\+\-]*)\s+", entry)
                if vp:
                    vp = float(vp.group(1))
                else:
                    vp = None

                solubility = re.search(r"\s+Water Solubility at 25 deg C \(mg/L\):\s+([e0-9\+\-\.]+)", entry)
                if solubility:
                    solubility = float(solubility.group(1)) / 1000
                else:
                    solubility = None

                log_kow = re.search(r"\s+Log Kow \(KOWWIN v1.69 estimate\)\s+=\s+(\-?[0-9]+\.[0-9]+)\s*", entry)
                if log_kow:
                    log_kow = float(log_kow.group(1))
                else:
                    log_kow = None

                if mol_id is None:
                    print(entry)

                parsed_results.append({"mol_id": mol_id,
                                       "smiles": smiles,
                                       "bp": bp,
                                       "mp": mp,
                                       "vp": vp,
                                       "solubility": solubility,
                                       "log_kow": log_kow})
        return parsed_results

    @staticmethod
    def parse_epi_suite_complete(file):
        """
        Parse predicted data from the US EPA's EPI Suite batch mode.

        Currently, this function only extracts the predicted boiling point,
        melting point, and solubility.

        :param file: Path to EPI Suite output file.
        :return: list of dicts with predicted molecular data
        """

        parsed_results = []

        with open(file, 'r', encoding="ISO-8859-1") as file:
            entries = file.read().split("\n\n========================\n\n")[0:-1]

            for entry in entries:
                smiles = re.search(r"SMILES\s+:\s+([A-Za-z0-9=\(\)#\[\]\+\-@]+\n?\s*[A-Za-z0-9=\(\)#\[\]\+\-@]*)",
                                   entry)
                if smiles:
                    smiles = smiles.group(1).replace("\n", "").replace(" ", "")
                else:
                    smiles = None

                name = re.search(r"CHEM\s+:\s+([A-Z/_a-z0-9]+)\s*", entry)
                if name:
                    mol_id = name.group(1)
                else:
                    mol_id = None

                bp = re.search(r"\s+\(Using BP:\s+(\-?[0-9]+\.[0-9]+) deg C", entry)
                if bp:
                    bp = float(bp.group(1))
                else:
                    bp = None

                mp = re.search(r"\s+Selected MP:\s+(\-?[0-9]+\.[0-9]+) deg C", entry)
                if mp:
                    mp = float(mp.group(1))
                else:
                    mp = None

                vp = re.search(r"\s+Selected VP:\s+([Ee0-9\+\-\.]+) mm Hg", entry)
                if vp:
                    vp = float(vp.group(1)) * 133.322
                else:
                    vp = None

                solubility = re.search(r"\s+Water Sol:\s+([Ee0-9\+\-\.]+) mg/L", entry)
                if solubility:
                    solubility = float(solubility.group(1))
                else:
                    solubility = None

                log_kow = re.search(r"\s+Log Kow\s+=\s+(\-?[0-9]+\.[0-9]+)", entry)
                if log_kow:
                    log_kow = float(log_kow.group(1))
                else:
                    log_kow = None

                parsed_results.append({"mol_id": mol_id,
                                       "smiles": smiles,
                                       "bp": bp,
                                       "mp": mp,
                                       "vp": vp,
                                       "solubility": solubility,
                                       "log_kow": log_kow})
        return parsed_results

    @staticmethod
    def store_epi_suite_db(entries, collection="episuite",
                           db_file="db.json"):
        """
        :param entries: List of dictionaries, with each entry representing the
        EPI Suite output data for a molecule.
        :param collection: Database collection for EPI Suite data. Default is
        "episuite".
        :return: list of mol_ids corresponding to all entries just added to
        collection.
        """

        try:
            db = QChemCalcDb.from_db_file(db_file)
        except:
            raise ConnectionFailure("db_file is invalid, or db listed cannot be"
                                    " connected to at this time.")

        collection = db.db[collection]

        collection.create_index("mol_id", unique=True)

        just_added = []

        for entry in entries:
            try:
                collection.insert_one(entry)
                just_added.append(entry["mol_id"])
            except DuplicateKeyError:
                continue

        return just_added
